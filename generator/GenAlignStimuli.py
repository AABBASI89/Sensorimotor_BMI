# -*- coding: utf-8 -*-
"""
Created on Mon Mar 27 13:23:39 2017

@author: Aamir Abbasi
"""

import pyqtgraph as pg
import pypylon.pylon as py
import sys
import os
import shutil
from PyQt4 import QtGui
import numpy as np
from shapely.geometry import Point
from PIL import Image, ImageDraw
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QT as NavigationToolbar

class Window(QtGui.QWidget):
    def __init__(self, parent=None):
        super(Window, self).__init__(parent)
        
        # A figure instance to show old reference image
        self.figure = plt.figure(facecolor='white')

        # Close the window generated by plt.figure()        
        plt.close()
        
        # A second figure instance to show new reference image
        self.figure2 = plt.figure(facecolor='white')   
 
        # Close the window generated by plt.figure()   
        plt.close()
        
        # A second figure instance to show the barrel map for generating the stimulus
        self.figure3 = plt.figure(facecolor='white')  

        # Close the window generated by plt.figure()   
        plt.close()

        # This is the Canvas Widget that displays the `figure`
        # it takes the `figure` instance as a parameter to __init__
        self.canvas = FigureCanvas(self.figure)
        self.canvas.setFixedSize(600,500)    
        self.canvas2 = FigureCanvas(self.figure2)
        self.canvas2.setFixedSize(600,500)           
        self.canvas3 = FigureCanvas(self.figure3)
        self.canvas3.setFixedSize(600,500)

        # This is the Navigation widget
        # it takes the Canvas widget and a parent
        self.toolbar = NavigationToolbar(self.canvas, self)
        self.toolbar.zoom()
        self.toolbar.setFixedSize(400,50)   
        self.toolbar2 = NavigationToolbar(self.canvas2, self)
        self.toolbar2.zoom()
        self.toolbar2.setFixedSize(600,50)            
        self.toolbar3 = NavigationToolbar(self.canvas3, self)
        #self.toolbar3.zoom()
        self.toolbar3.setFixedSize(400,50)
                        
        # Button to load the reference images
        self.button = QtGui.QPushButton('Load Vessel Images')
        self.button.clicked.connect(self.getImageAndDisplay)
        
        # Button to get the stimuli and display it over the old reference image
        self.button2 = QtGui.QPushButton('Display Stimuli')
        self.button2.clicked.connect(self.getStimuliAndDisplay)

        # Button to align the stimuli and display over new reference image
        self.button3 = QtGui.QPushButton('Align Stimuli') 
        self.button3.clicked.connect(self.getAlignedStimuliAndDisplay)
        
        # Button to generate the topographical stimuli
        self.button4 = QtGui.QPushButton('Load Barrel Map') 
        self.button4.clicked.connect(self.getBarrelMap)
        
        # Button to generate the random stimuli
        self.button5 = QtGui.QPushButton('Generate Stimuli') 
        self.button5.clicked.connect(self.genStimuli)
        
        # Button to start live imaging
        self.button6 = QtGui.QPushButton('Start Camera Live')
        self.button6.clicked.connect(self.startLiveCamera)

        # Button to stop live imaging
        self.button7 = QtGui.QPushButton('Stop Camera Live')
        self.button7.clicked.connect(self.stopLiveCamera)
        
        # Buttons to clear the selection of barrels centers and vessel locations
        self.button8 = QtGui.QPushButton('Clear')
        self.button8.clicked.connect(self.clearBarrelCenters)
        
        self.button9 = QtGui.QPushButton('Clear')
        self.button9.clicked.connect(self.clearVesselLocations)
        
        # Button to reset the view of the barrel canvas to the defalut view
        self.button10 = QtGui.QPushButton('Reset')
        self.button10.clicked.connect(self.resetViewBarrelMap)
        
        # Button to reset the view of the vessel canvas to the default view
        self.button11 = QtGui.QPushButton('Reset')
        self.button11.clicked.connect(self.resetViewVessels)
        
        # Button to get the source path of stimulation images
        self.button12 = QtGui.QPushButton('Get Path')
        self.button12.clicked.connect(self.getStimulationDirectory)
        
        # Button to lauch the template matching window
        self.button13 = QtGui.QPushButton('Launch Viewer')
        self.button13.clicked.connect(self.launchViewer)
        
        # A Line Edit widget for entering the path for the location of stimulation images
        self.stim_path_label = QtGui.QLabel(self)
        self.stim_path_label.setText("PATH: Stimulation Images")
        self.stim_path = QtGui.QLineEdit(self)
        self.stim_path.setText("E:/ownCloud/BMI/Data/mouse45/Frames/topy")  
                
        # A Line edit widget for entering the number of barrels required in the stimuli
        self.number_barrels_label = QtGui.QLabel(self)
        self.number_barrels_label.setText("Number of Barrels")
        self.number_barrels = QtGui.QLineEdit(self)
        self.number_barrels.setText("22")
        
        # A lind edit widget for entering the number of barrels required in the stimuli
        self.size_stim_label = QtGui.QLabel(self)
        self.size_stim_label.setText("Spot Size")
        self.size_stim = QtGui.QLineEdit(self)
        self.size_stim.setText("10")
        
        # set the layout
        hlayout_stim_path = QtGui.QHBoxLayout()
        hlayout_stim_path.addWidget(self.stim_path_label)
        hlayout_stim_path.addWidget(self.stim_path)
        hlayout_stim_path.addWidget(self.button12)
        
        hlayout_pushButtons = QtGui.QHBoxLayout()
        hlayout_pushButtons.addWidget(self.button13)
        hlayout_pushButtons.addWidget(self.button6)
        hlayout_pushButtons.addWidget(self.button7)
        hlayout_pushButtons.addWidget(self.button)
        hlayout_pushButtons.addWidget(self.button2)
        hlayout_pushButtons.addWidget(self.button3)
       
        hlayout_canvas = QtGui.QHBoxLayout()
        hlayout_canvas.addWidget(self.canvas3)        
        hlayout_canvas.addWidget(self.canvas)
        hlayout_canvas.addWidget(self.canvas2)
        
        hlayout_toolbar = QtGui.QHBoxLayout()
        hlayout_toolbar.addWidget(self.toolbar3)
        hlayout_toolbar.addWidget(self.button8)
        hlayout_toolbar.addWidget(self.button10)
        hlayout_toolbar.addWidget(self.toolbar)
        hlayout_toolbar.addWidget(self.button9)
        hlayout_toolbar.addWidget(self.button11)        
        hlayout_toolbar.addWidget(self.toolbar2)
        
        hlayout_nBarrels = QtGui.QHBoxLayout()
        hlayout_nBarrels.addWidget(self.number_barrels_label)
        hlayout_nBarrels.addWidget(self.number_barrels)
        
        hlayout_sStim = QtGui.QHBoxLayout()
        hlayout_sStim.addWidget(self.size_stim_label)
        hlayout_sStim.addWidget(self.size_stim)
                
        hlayout_stimButtons = QtGui.QHBoxLayout()        
        hlayout_stimButtons.addWidget(self.button4)
        hlayout_stimButtons.addWidget(self.button5) 
        
        hlayout_stimLineEdit = QtGui.QHBoxLayout()      
        hlayout_stimLineEdit.addLayout(hlayout_nBarrels) 
        hlayout_stimLineEdit.addLayout(hlayout_sStim) 
        
        vlayout_stim = QtGui.QVBoxLayout()
        vlayout_stim.addLayout(hlayout_stimLineEdit)
        vlayout_stim.addLayout(hlayout_stimButtons)      
             
        hlayout_stimPanel = QtGui.QHBoxLayout()
        hlayout_stimPanel.addLayout(vlayout_stim)
        
        layout = QtGui.QVBoxLayout()
        layout.addLayout(hlayout_stim_path)
        layout.addLayout(hlayout_pushButtons)
        layout.addLayout(hlayout_toolbar)        
        layout.addLayout(hlayout_canvas)
        layout.addLayout(hlayout_stimPanel)

        self.setLayout(layout)
        
        # Initialize a global varialbe holding the barrel coordinates        
        self.coordinates = []
        
    def launchViewer(self):  
                     
        viewer = Pyqtgraph_Window()
        viewer.setWindowTitle('Template Alignment GUI')    
        viewer.show()
        
    def getStimulationDirectory(self):
        
        # Get directory where stimulation images are stored
        directory = QtGui.QFileDialog.getOpenFileName(self, 'Open file', 
         'f:\\',"Image files (*.tiff *.tif *.png *.jpeg *.jpg)")  
        
        # Set the path on the Qlable widget self.stim_path
        directory = os.path.dirname(directory)
        self.stim_path.setText(directory)
            
    def storeVesselCoordinates(self):
        # Store vessel references for both images
        print("Store vessel coordinates")
        self.vessel_pos = []
        self.vessel_pos.append(self.y_pos_vessel[0])
        self.vessel_pos.append(self.x_pos_vessel[0])
        self.vessel_pos.append(self.y_pos_vessel[1])
        self.vessel_pos.append(self.x_pos_vessel[1]) 
        print (self.vessel_pos)
    
    def onclick(self,event):
           
        print("On Click")
        ix, iy = event.xdata, event.ydata
        self.x_pos_vessel.append(round(ix))
        self.y_pos_vessel.append(round(iy))
        if len(self.x_pos_vessel) == 1:        
            self.ax.scatter([round(ix)], [round(iy)], c = 'c', s = 500, edgecolor ='none', marker='+')   
            self.ax2.scatter([round(ix)], [round(iy)], c = 'c', s = 500, edgecolor ='none', marker='+') 
            self.canvas.draw()    
            self.canvas2.draw()            
        if len(self.x_pos_vessel) == 2: 
            self.ax.scatter([round(ix)], [round(iy)], c = 'w', s = 500, edgecolor ='none', marker='+')   
            self.ax2.scatter([round(ix)], [round(iy)], c = 'w', s = 500, edgecolor ='none', marker='+')  
            self.canvas.draw()    
            self.canvas2.draw()
        if len(self.x_pos_vessel) == 2:
            # refresh canvas
            self.figure.canvas.mpl_disconnect(self.cid)
            self.figure2.canvas.mpl_disconnect(self.cid)
            self.storeVesselCoordinates()

    def clearVesselLocations(self):
        
        # Clean the axes to avoid overdrawing of images and stimuli on the figure canvas        
        self.ax.clear()
        self.ax2.clear()
        self.canvas.draw()
        self.canvas2.draw()
        
        # Clear previous vessel selection
        self.x_pos_vessel.clear()
        self.y_pos_vessel.clear()

        # Plot the old reference image
        self.ax.imshow(self.ref1, interpolation = 'none', cmap = 'gray')
        self.figure.suptitle('Old Reference Image',color='b')
        self.ax.set_xlim(365,1024)
        self.ax.set_ylim(768,274)
        self.ax.axis('off')
        self.cid = self.figure.canvas.mpl_connect('button_press_event', self.onclick)
        self.zoom_factory(self.ax, base_scale = 2)

        # Plot the new reference image
        self.ax2.imshow(self.ref2, interpolation = 'none', cmap = 'gray')
        self.figure2.suptitle('New Reference Image',color='b')
        self.ax2.set_xlim(365,1024)
        self.ax2.set_ylim(768,274)     
        self.ax2.axis('off')
        self.cid2 = self.figure2.canvas.mpl_connect('button_press_event', self.onclick)
        self.zoom_factory(self.ax2, base_scale = 2)
        
        # refresh canvas        
        self.canvas.draw()    
        self.canvas2.draw()          
        
    def resetViewVessels(self):
        
        # Change the limits of axis to default
        self.ax.set_xlim(365,1024)
        self.ax.set_ylim(768,274)  
        
        # Change the limits of axis to default
        self.ax2.set_xlim(365,1024)
        self.ax2.set_ylim(768,274)  
        
        # refresh canvas        
        self.canvas.draw()    
        self.canvas2.draw()     
        
    def mouse_move(self, event):
        print("On Mouse move")        
        if not event.inaxes:
            return

        x, y = event.xdata, event.ydata
        # update the line positions
        self.lx.set_ydata(y)
        self.ly.set_xdata(x)

        self.canvas3.draw() 
        
    def on_multiple_clicks(self, event):
        
        print("On Multiple Clicks")
        ix, iy = event.xdata, event.ydata
        self.x_pos.append(round(ix)) 
        self.y_pos.append(round(iy)) 
        self.ax3.scatter([round(ix)], [round(iy)], c = 'r', s = 200, edgecolor = 'none', marker = 'o')
        self.canvas3.draw()        
        if self.nBarrels == 4:
            if len(self.x_pos) == self.nBarrels: 
                self.figure3.canvas.mpl_disconnect(self.cid31)
                self.figure3.canvas.mpl_disconnect(self.cid32)
                self.coordinates = np.array([self.x_pos, self.y_pos])
                # save barrel locations in a parameter file
                self.savePath = os.path.dirname(str(self.stim_path.text())) + "/barrel_centers_control.npy" #os.path.dirname(str(self.stim_path.text()))
                np.save(self.savePath,self.coordinates)
        else:
            if len(self.x_pos) == self.nBarrels: 
                self.figure3.canvas.mpl_disconnect(self.cid31)
                self.figure3.canvas.mpl_disconnect(self.cid32)
                self.coordinates = np.array([self.x_pos, self.y_pos])
                # save barrel locations in a parameter file
                self.savePath = os.path.dirname(str(self.stim_path.text())) + "/barrel_centers.npy" #os.path.dirname(str(self.stim_path.text()))
                np.save(self.savePath,self.coordinates)
            
    def clearBarrelCenters(self):
        
        # clear the axis and refresh the canvas        
        self.ax3.clear()  
        self.canvas3.draw()
        
        # clear the x and y coordinates
        self.x_pos.clear()
        self.y_pos.clear()
        
        # Plot the barrel map
        self.ax3.imshow(self.img, interpolation = 'none', cmap = 'gray')
        self.figure3.suptitle('Barrel Map',color='b')
        self.ax3.set_xlim(365,1024)
        self.ax3.set_ylim(768,274)    
        
        # Add vertical and horizontal lines on the figure        
        self.lx = self.ax3.axhline(color='g',linewidth=2)  # the horiz line
        self.ly = self.ax3.axvline(color='g',linewidth=2)  # the vert line      
        self.ax3.axis('off')
        self.cid31 = self.figure3.canvas.mpl_connect('button_press_event', self.on_multiple_clicks)  
        self.cid32 = self.figure3.canvas.mpl_connect('motion_notify_event', self.mouse_move)
        self.zoom_factory(self.ax3, base_scale = 2)
        
        # refresh canvas
        self.canvas3.draw()
        
    def resetViewBarrelMap(self):
        
        # Change the limits of axis to default
        self.ax3.set_xlim(365,1024)
        self.ax3.set_ylim(768,274)  
        
        # refresh canvas
        self.canvas3.draw()
            
    def zoom_factory(self,ax,base_scale = 2.):
        def zoom(event):
            cur_xlim = ax.get_xlim()
            cur_ylim = ax.get_ylim()
    
            xdata = event.xdata # get event x location
            ydata = event.ydata # get event y location
    
            if event.button == 'down':
                # deal with zoom in
                scale_factor = 1 / 2
            elif event.button == 'up':
                # deal with zoom out
                scale_factor = 2
            else:
                # deal with something that should never happen
                scale_factor = 1
                print (event.button)
    
            new_width = (cur_xlim[1] - cur_xlim[0]) * scale_factor
            new_height = (cur_ylim[1] - cur_ylim[0]) * scale_factor
    
            relx = (cur_xlim[1] - xdata)/(cur_xlim[1] - cur_xlim[0])
            rely = (cur_ylim[1] - ydata)/(cur_ylim[1] - cur_ylim[0])
    
            ax.set_xlim([xdata - new_width * (1-relx), xdata + new_width * (relx)])
            ax.set_ylim([ydata - new_height * (1-rely), ydata + new_height * (rely)])
            ax.figure.canvas.draw()
            
        fig = ax.get_figure() # get the figure of interest
        fig.canvas.mpl_connect('scroll_event', zoom)

        return zoom            
    
    def plot_poly(self,poly):
        
        print("Plot Poly")     
        x,y = poly.exterior.coords.xy
        poly.fill(x,y, alpha=0.5)

    def draw_poly(self,poly, img):
        print("Draw Poly")             
        x,y = poly.exterior.coords.xy
        coord = []
        for i in range(len(x)):
            coord.append((x[i], y[i]))
    
        ImageDraw.Draw(img).polygon(coord, fill="white")

    def time_sequence(self,space_pattern, pattern_number, time_pattern, folder):
        # time_pattern is a sequence of 0 and 1, such as [0,0,1,1,1,0,0,0,0]
        # 0 will be fully dark, while 1 corresponds to the space pattern, in full. 
        print("Time Sequence")        
        black = Image.new('L', (1024,768), 0)

        for i in range(len(time_pattern)):
            if time_pattern[i] == 0:
                black.save(folder + str(pattern_number) + "_" + str(i) + ".tiff")
            else:
                space_pattern.save(folder + str(pattern_number) + "_" + str(i) + ".tiff")
         
    def getImageAndDisplay(self):

        print("Get Image And Display")  
        
        # Initialize the mouse click positions
        self.x_pos_vessel = []
        self.y_pos_vessel = []        
          
        # Define the axes        
        self.ax = self.figure.add_axes([0,0,1,1], frameon=False, xticks=[], yticks=[])
        self.ax2 = self.figure2.add_axes([0,0,1,1], frameon=False, xticks=[], yticks=[])
      
        # Clean the axes to avoid overdrawing of images and stimuli on the figure canvas        
        self.ax.clear()
        self.ax2.clear()
        self.canvas.draw()
        self.canvas2.draw()
        
        fname = QtGui.QFileDialog.getOpenFileName(self, 'Open file', 
         'f:\\',"Image files (*.tiff *.tif *.png *.jpeg *.jpg)")  

        ref_img1_path = os.path.dirname(fname) +'/img_ref.tiff'
        ref_img2_path = fname
        # Read the old reference image and resize it to the size of the stimulus image
        self.ref1 = Image.open(ref_img1_path)
        self.ref1 = self.ref1.resize((659, 494))
        self.ref1 = np.rot90(np.rot90(self.ref1))
        
        # Store the old reference image as a numpy array and apply gaussian filter for image smoothing
        ref1_bucket = np.zeros([768,1024],'uint16')          
        self.ref1 = np.asarray(self.ref1)
        ref1_dim = np.shape(self.ref1)
        ref1_bucket[np.shape(ref1_bucket)[0]-ref1_dim[0]:np.shape(ref1_bucket)[0],np.shape(ref1_bucket)[1]-ref1_dim[1]:np.shape(ref1_bucket)[1]] = self.ref1
        self.ref1 = ref1_bucket        
        
        # Plot the old reference image
        self.ax.imshow(self.ref1, interpolation = 'none', cmap = 'gray')
        self.figure.suptitle('Old Reference Image',color='b')
        self.ax.set_xlim(365,1024)
        self.ax.set_ylim(768,274)
        self.ax.axis('off')
        self.cid = self.figure.canvas.mpl_connect('button_press_event', self.onclick)
        self.zoom_factory(self.ax, base_scale = 2)
       
        # Read the new reference image and resize it to the size of the stimulus image
        self.ref2 = Image.open(ref_img2_path)
        self.ref2 = self.ref2.resize((659, 494))
        self.ref2 = np.rot90(np.rot90(self.ref2))
        
        # Store the old reference image as a numpy array and apply gaussian filter for image smoothing
        ref2_bucket = np.zeros([768,1024],'uint16') 
        self.ref2 = np.asarray(self.ref2)
        ref2_dim = np.shape(self.ref2)
        ref2_bucket[np.shape(ref2_bucket)[0]-ref2_dim[0]:np.shape(ref2_bucket)[0],np.shape(ref2_bucket)[1]-ref2_dim[1]:np.shape(ref2_bucket)[1]] = self.ref2
        self.ref2 = ref2_bucket
        
        # Plot the new reference image
        self.ax2.imshow(self.ref2, interpolation = 'none', cmap = 'gray')
        self.figure2.suptitle('New Reference Image',color='b')
        self.ax2.set_xlim(365,1024)
        self.ax2.set_ylim(768,274)     
        self.ax2.axis('off')
        self.cid2 = self.figure2.canvas.mpl_connect('button_press_event', self.onclick)
        self.zoom_factory(self.ax2, base_scale = 2)
             
        # refresh canvas
        self.canvas.draw()
        self.canvas2.draw()
                        
    def getStimuliAndDisplay(self):
        
        print("Get Stimuli And Display")   
        if str(self.stim_path.text()).endswith("rand"):
            print('rand')
            self.savePath = os.path.dirname(str(self.stim_path.text()))
            self.savePath = self.savePath + "/barrel_centers_rand.npy"
            self.stim_location = np.load(self.savePath)   
        elif str(self.stim_path.text()).endswith("control"):
            print('control')
            self.savePath = os.path.dirname(str(self.stim_path.text()))
            self.savePath = self.savePath + "/barrel_centers_control.npy"
            self.stim_location = np.load(self.savePath) 
        else:
            self.savePath = os.path.dirname(str(self.stim_path.text()))
            self.savePath = self.savePath + "/barrel_centers.npy"
            self.stim_location = np.load(self.savePath)  

        
        # Plot detected locations over the vessel image
        self.ax.scatter(self.stim_location[0], self.stim_location[1], s=10, c='red', edgecolor ='none', marker='o')

        # refresh canvas
        self.canvas.draw()
        
    def getAlignedStimuliAndDisplay(self):
        
        print("Get Aligned Stimuli And Display")  
                            
        # Align the stimuli based on the shift in vessel position from the previous session
        new_stim_locations = []
        if  self.vessel_pos[0] == self.vessel_pos[2]:
            print("Translate x")            
            translation_distance = self.vessel_pos[1] - self.vessel_pos[3]
            changed_stim_location = self.stim_location[1] - translation_distance
            new_stim_locations.append(self.stim_location[0])
            new_stim_locations.append(changed_stim_location)
            
        elif  self.vessel_pos[1] == self.vessel_pos[3]:    
            print("Translate y")            
            translation_distance = self.vessel_pos[0] - self.vessel_pos[2]
            changed_stim_location = self.stim_location[0] - translation_distance
            new_stim_locations.append(changed_stim_location)
            new_stim_locations.append(self.stim_location[1])
            
        elif self.vessel_pos[0] != self.vessel_pos[2] and self.vessel_pos[1] != self.vessel_pos[3]:
            print("Translate x y")            
            translation_distance_x = self.vessel_pos[0] - self.vessel_pos[2]
            translation_distance_y = self.vessel_pos[1] - self.vessel_pos[3]
            changed_stim_location = self.stim_location[0] - translation_distance_y
            new_stim_locations.append(changed_stim_location)    
            changed_stim_location = self.stim_location[1] - translation_distance_x
            new_stim_locations.append(changed_stim_location)
            
        else:
            print("No change")            
            new_stim_locations.append(self.stim_location[0]) 
            new_stim_locations.append(self.stim_location[1])  
        
        # Plot the aligned stimuli on the new reference image      
        self.ax2.scatter(new_stim_locations[0], new_stim_locations[1],
                   s=10, c='blue', edgecolor ='none', marker='o')        
           
        # refresh canvas
        self.canvas2.draw()
                        
        # Store new coordinates location to generate new stimulation images
        self.coordinates = np.array([new_stim_locations[0], new_stim_locations[1]])
        
    def getBarrelMap(self):
        
        print("Get Barrel Map")  
        # initialize mouse click positions       
        self.x_pos = []
        self.y_pos = [] 
        # Define the axes        
        self.ax3 = self.figure3.add_axes([0,0,1,1], frameon=False, xticks=[], yticks=[])
        
        # Clean the axes to avoid overdrawing of images and stimuli on the figure canvas        
        self.ax3.clear()
        self.canvas3.draw()  
        
        # Get the number of barrels required in the stimuli
        self.nBarrels = int(self.number_barrels.text())
        
        iname = QtGui.QFileDialog.getOpenFileName(self, 'Open file', 
         'f:\\',"Image files (*.tiff *.tif *.png *.jpeg *.jpg)")    
         
        barrel_map_path = iname 

        # Read the barrel map and resize it to the size of the stimulus image
        img = Image.open(barrel_map_path)
        if img.mode == 'RGBA':
            img = img.convert('L')
        img = img.resize((659, 494))
        img = np.rot90(np.rot90(img))
        
        # Store barrel map image as a numpy array 
        img = np.asarray(img)
        img_bucket = np.zeros([768,1024],'uint16')          
        img_dim = np.shape(img)
        img_bucket[np.shape(img_bucket)[0]-img_dim[0]:np.shape(img_bucket)[0],np.shape(img_bucket)[1]-img_dim[1]:np.shape(img_bucket)[1]] = img
        self.img = img_bucket    
        
        # Plot the barrel map
        self.ax3.imshow(self.img, interpolation = 'none', cmap = 'gray')
        self.figure3.suptitle('Barrel Map',color='b')
        self.ax3.set_xlim(365,1024)
        self.ax3.set_ylim(768,274)    
        
        # Add vertical and horizontal lines on the figure        
        self.lx = self.ax3.axhline(color='g',linewidth=2)  # the horiz line
        self.ly = self.ax3.axvline(color='g',linewidth=2)  # the vert line      
        self.ax3.axis('off')
        self.cid31 = self.figure3.canvas.mpl_connect('button_press_event', self.on_multiple_clicks)  
        self.cid32 = self.figure3.canvas.mpl_connect('motion_notify_event', self.mouse_move)
        self.zoom_factory(self.ax3, base_scale = 2)
        
        # refresh canvas
        self.canvas3.draw()

    def subfolders(self,path_to_parent):
        try:
            return next(os.walk(path_to_parent))[1]
        except StopIteration:
            return []

    def genStimuli(self):
        
        print("Gen Stimuli")
        stimPath = str(self.stim_path.text()) 
        print(stimPath)

        # If the directory exists and not empty then move the current frames to a new folder
        if os.path.exists(stimPath) and os.listdir(stimPath) != []:
            
            # Get only images for the directory            
            images = [f for f in os.listdir(stimPath) if os.path.isfile(os.path.join(stimPath,f))]    
           
            # check if folder exist in the directory if yes then detect the session number
            folder = self.subfolders(stimPath)
            if folder != []:     
                lastSession = folder[len(folder)-1]
                lastSession = int(lastSession[-2:]) 
                nextSession = lastSession + 1
                
                if nextSession < 10:
                    destination = stimPath + '/Session0' + str(nextSession)
                    os.mkdir(destination)

                else:
                    destination = stimPath + '/Session' + str(nextSession)
                    os.mkdir(destination)
                                                        
            # else name the folder as session01   
            else:  
                destination = stimPath + '/Session00'
                os.mkdir(destination)
            
            # move the images to the generated folder
            for f in images:
                shutil.move(stimPath + '/' + f, destination + '/')
          
        # Make directory for storing stimulation images if it dosen't exits        
        if not os.path.exists(stimPath):
            os.makedirs(stimPath)
                       
        # Get stimulus spot size
        stimSize = int(self.size_stim.text())   
        
        # Get number of barrels
        self.nBarrels = int(self.number_barrels.text())
                
        # Initialize the list contaning stimuli spots
        barrel_geometry = []
        
        # define folder where stimi will be stored            
        folder = stimPath + "/" 
        
        # For somatotopical feedback 
        if stimPath.endswith("topy"):
            print("topy")
            
            # Overwrite the number of barrels by 22
            self.nBarrels = 22
            
            # To generate stimuli if barrel centers are not loaded before
            if self.coordinates == []:
                self.savePath = os.path.dirname(str(self.stim_path.text()))
                self.savePath = self.savePath + "/barrel_centers.npy"
                coordinates = np.load(self.savePath)
                self.coordinates = np.array([coordinates[0], coordinates[1]])

            # position barrel geometries
            for c in range(self.nBarrels):
                barrel_geometry.append(Point(self.coordinates[0,c], self.coordinates[1,c]).buffer(stimSize))
                                   
            time_pattern = [1]
                         
            # create the image
            img = Image.new('L', (1024, 768), 0)
                    
            # loop through barrels
            for b in range(self.nBarrels):

                if b < 4:
                    self.draw_poly(barrel_geometry[b], img)                
                    if b == 3:                   
                        self.draw_poly(barrel_geometry[b+3], img)
                    self.time_sequence(img, 0, time_pattern, folder)     
                    if b == 3:                    
                        img = Image.new('L', (1024, 768), 0)  
                        self.draw_poly(barrel_geometry[b], img)                        
                        self.draw_poly(barrel_geometry[b+1], img)
                        self.draw_poly(barrel_geometry[b+2], img)
                        self.draw_poly(barrel_geometry[b+3], img)
                        self.draw_poly(barrel_geometry[b+4], img)
                        self.time_sequence(img, 1, time_pattern, folder)
                        img = Image.new('L', (1024, 768), 0) 
                        
                elif b > 3 and b < 9:
                    if b == 8:                    
                        img = Image.new('L', (1024, 768), 0)  
                        self.draw_poly(barrel_geometry[b], img)                        
                        self.draw_poly(barrel_geometry[b-1], img)
                        self.draw_poly(barrel_geometry[b-3], img)
                        self.draw_poly(barrel_geometry[b-4], img)
                        self.draw_poly(barrel_geometry[b+3], img)
                        self.time_sequence(img, 2, time_pattern, folder)
                        img = Image.new('L', (1024, 768), 0) 
                    if b == 8:                    
                        img = Image.new('L', (1024, 768), 0)  
                        self.draw_poly(barrel_geometry[b], img)                        
                        self.draw_poly(barrel_geometry[b-4], img)
                        self.draw_poly(barrel_geometry[b+2], img)
                        self.draw_poly(barrel_geometry[b+3], img)
                        self.draw_poly(barrel_geometry[b+4], img)
                        self.time_sequence(img, 3, time_pattern, folder)
                        img = Image.new('L', (1024, 768), 0) 
                elif b > 8 and b < 14:
                    if b == 13:                    
                        img = Image.new('L', (1024, 768), 0)   
                        self.draw_poly(barrel_geometry[b], img)
                        self.draw_poly(barrel_geometry[b-1], img)  
                        self.draw_poly(barrel_geometry[b-3], img)                         
                        self.draw_poly(barrel_geometry[b-4], img) 
                        self.draw_poly(barrel_geometry[b+3], img)  
                        self.time_sequence(img, 4, time_pattern, folder)
                        img = Image.new('L', (1024, 768), 0)
                elif b > 13 and b < 20:                   
                    if b == 18:
                        img = Image.new('L', (1024, 768), 0)   
                        self.draw_poly(barrel_geometry[b], img)
                        self.draw_poly(barrel_geometry[b-1], img)
                        self.draw_poly(barrel_geometry[b-2], img)
                        self.draw_poly(barrel_geometry[b-8], img)
                        self.draw_poly(barrel_geometry[b-9], img)                      
                        self.time_sequence(img, 5, time_pattern, folder)
                        img = Image.new('L', (1024, 768), 0)
                    if b == 15:
                        img = Image.new('L', (1024, 768), 0)   
                        self.draw_poly(barrel_geometry[b], img)
                        self.draw_poly(barrel_geometry[b+1], img)
                        self.draw_poly(barrel_geometry[b+3], img)
                        self.draw_poly(barrel_geometry[b+5], img)
                        self.draw_poly(barrel_geometry[b-6], img)                      
                        self.time_sequence(img, 6, time_pattern, folder)
                        img = Image.new('L', (1024, 768), 0)                        
                elif b > 19 and b < 22:
                    if b == 21:
                        img = Image.new('L', (1024, 768), 0)   
                        self.draw_poly(barrel_geometry[b], img)
                        self.draw_poly(barrel_geometry[b-1], img)
                        self.draw_poly(barrel_geometry[b-2], img)
                        self.draw_poly(barrel_geometry[b-6], img)
                        self.draw_poly(barrel_geometry[b-7], img)                      
                        self.time_sequence(img, 7, time_pattern, folder)
                        img = Image.new('L', (1024, 768), 0)                        
                else:
                    print("")

        # For somatotopical_90 feedback
        if stimPath.endswith("topy_90"):
            print("topy_90")
            
            # Overwrite the number of barrels by 22
            self.nBarrels = 22
            
            # To generate stimuli if barrel centers are not loaded before
            if self.coordinates == []:
                self.savePath = os.path.dirname(str(self.stim_path.text()))
                self.savePath = self.savePath + "/barrel_centers.npy"
                coordinates = np.load(self.savePath)
                self.coordinates = np.array([coordinates[0], coordinates[1]])         

            # position barrel geometries
            for c in range(self.nBarrels):
                barrel_geometry.append(Point(self.coordinates[0,c], self.coordinates[1,c]).buffer(stimSize))
                                   
            time_pattern = [1]
            
            # define location of spots for each frame
            frame0 = [0, 4, 9, 14, 10]
            frame1 = [0, 5, 10, 15, 14]
            frame2 = [1, 5, 10, 15, 19]
            frame3 = [1, 6, 11, 16, 19]
            frame4 = [2, 6, 11, 16, 20]
            frame5 = [2, 7, 12, 17, 20]
            frame6 = [3, 7, 12, 17, 21]
            frame7 = [3, 8, 13, 18, 21]
                         
            img = Image.new('L', (1024, 768), 0)
            for b in range(len(frame0)):
                self.draw_poly(barrel_geometry[frame0[b]], img) 
            self.time_sequence(img, 0, time_pattern, folder)
             
            img = Image.new('L', (1024, 768), 0)             
            for b in range(len(frame1)):
                self.draw_poly(barrel_geometry[frame1[b]], img) 
            self.time_sequence(img, 1, time_pattern, folder)
               
            img = Image.new('L', (1024, 768), 0)               
            for b in range(len(frame2)):
                self.draw_poly(barrel_geometry[frame2[b]], img) 
            self.time_sequence(img, 2, time_pattern, folder)

            img = Image.new('L', (1024, 768), 0)
            for b in range(len(frame3)):
                self.draw_poly(barrel_geometry[frame3[b]], img) 
            self.time_sequence(img, 3, time_pattern, folder)

            img = Image.new('L', (1024, 768), 0)
            for b in range(len(frame4)):
                self.draw_poly(barrel_geometry[frame4[b]], img) 
            self.time_sequence(img, 4, time_pattern, folder)

            img = Image.new('L', (1024, 768), 0)
            for b in range(len(frame5)):
                self.draw_poly(barrel_geometry[frame5[b]], img) 
            self.time_sequence(img, 5, time_pattern, folder)

            img = Image.new('L', (1024, 768), 0)
            for b in range(len(frame6)):
                self.draw_poly(barrel_geometry[frame6[b]], img) 
            self.time_sequence(img, 6, time_pattern, folder)

            img = Image.new('L', (1024, 768), 0)
            for b in range(len(frame7)):
                self.draw_poly(barrel_geometry[frame7[b]], img) 
            self.time_sequence(img, 7, time_pattern, folder)                
                     
        # For destructured feedback           
        if stimPath.endswith("rand"):
            print("rand")
            
            # Overwrite the number of barrels by 22
            self.nBarrels = 22            
            
            # Load barrel centers
            if os.path.isfile(os.path.dirname(str(self.stim_path.text())) + "/barrel_centers_rand.npy") and self.coordinates == []:
                print("file exists")
                self.savePath = os.path.dirname(str(self.stim_path.text()))
                self.savePath = self.savePath + "/barrel_centers_rand.npy" 
                coordinates = np.load(self.savePath)
                self.coordinates = np.array([coordinates[0], coordinates[1]])
            
            # Shuffle and save barrel centers
            if os.path.isfile(os.path.dirname(str(self.stim_path.text())) + "/barrel_centers_rand.npy") == False:
                print("shuffle location")
                # Load the barrel coordinates
                self.savePath = os.path.dirname(str(self.stim_path.text()))
                self.savePath = self.savePath + "/barrel_centers.npy" 
                coordinates = np.load(self.savePath)
                
                # Shuffle the barrel coordinates 
                location = os.path.dirname(os.path.dirname(os.path.dirname(self.savePath))) + "/shuffled_list_barrel_centers.npy"
                shuffled_coordintes = np.load(location)                
                x = []
                y = []
                for i in range(len(shuffled_coordintes)):
                    x.append(coordinates[0][shuffled_coordintes[i]])
                    y.append(coordinates[1][shuffled_coordintes[i]])
                self.coordinates = np.array([x,y])
                
                # save in a npy file
                self.savePath = os.path.dirname(str(self.stim_path.text()))
                self.savePath = self.savePath + "/barrel_centers_rand.npy"                
                np.save(self.savePath,self.coordinates)
            
            # position barrel geometries
            for c in range(self.nBarrels):
                barrel_geometry.append(Point(self.coordinates[0,c], self.coordinates[1,c]).buffer(stimSize))
                       
            time_pattern = [1]

            # define location of spots for each frame
            frame0 = [0, 1, 2, 3, 4]
            frame1 = [5, 6, 7, 8, 9]
            frame2 = [10, 11, 12, 13, 14]
            frame3 = [15, 16, 17, 18, 19]
            frame4 = [20, 21, 2, 9, 15]
            frame5 = [5, 8, 13, 12, 14]
            frame6 = [3, 7, 12, 17, 21]
            frame7 = [1, 8, 11, 4, 20]
                         
            img = Image.new('L', (1024, 768), 0)
            for b in range(len(frame0)):
                self.draw_poly(barrel_geometry[frame0[b]], img) 
            self.time_sequence(img, 0, time_pattern, folder)
             
            img = Image.new('L', (1024, 768), 0)             
            for b in range(len(frame1)):
                self.draw_poly(barrel_geometry[frame1[b]], img) 
            self.time_sequence(img, 1, time_pattern, folder)
               
            img = Image.new('L', (1024, 768), 0)               
            for b in range(len(frame2)):
                self.draw_poly(barrel_geometry[frame2[b]], img) 
            self.time_sequence(img, 2, time_pattern, folder)

            img = Image.new('L', (1024, 768), 0)
            for b in range(len(frame3)):
                self.draw_poly(barrel_geometry[frame3[b]], img) 
            self.time_sequence(img, 3, time_pattern, folder)

            img = Image.new('L', (1024, 768), 0)
            for b in range(len(frame4)):
                self.draw_poly(barrel_geometry[frame4[b]], img) 
            self.time_sequence(img, 4, time_pattern, folder)

            img = Image.new('L', (1024, 768), 0)
            for b in range(len(frame5)):
                self.draw_poly(barrel_geometry[frame5[b]], img) 
            self.time_sequence(img, 5, time_pattern, folder)

            img = Image.new('L', (1024, 768), 0)
            for b in range(len(frame6)):
                self.draw_poly(barrel_geometry[frame6[b]], img) 
            self.time_sequence(img, 6, time_pattern, folder)

            img = Image.new('L', (1024, 768), 0)
            for b in range(len(frame7)):
                self.draw_poly(barrel_geometry[frame7[b]], img) 
            self.time_sequence(img, 7, time_pattern, folder)                         
        
        # For no feedback protocol
        if stimPath.endswith("black"):
            print("black")
            
            # Seven black frames
            time_pattern = [0]
                        
            for c in range(0, 8): # Eight black frames
            
                # create the image
                img = Image.new('L', (1024, 768), 0)
                
                # generate black frames
                self.time_sequence(img, c, time_pattern, folder)
                
        # For control recording on S1
        if stimPath.endswith("control"):
            print("control")
            
            # first black frame
            time_pattern = [0]
            img = Image.new('L', (1024, 768), 0)
            self.time_sequence(img, 0, time_pattern, folder)
            
            # last black frame
            time_pattern = [0]
            img = Image.new('L', (1024, 768), 0)
            self.time_sequence(img, 5, time_pattern, folder)
            
            # Overwrite the number of barrels 
            self.nBarrels = 4
            
            # Load barrel centers
            if os.path.isfile(os.path.dirname(str(self.stim_path.text())) + "/barrel_centers_control.npy") and self.coordinates == []:
                print("file exists")
                self.savePath = os.path.dirname(str(self.stim_path.text()))
                self.savePath = self.savePath + "/barrel_centers_rand.npy" 
                coordinates = np.load(self.savePath)
                self.coordinates = np.array([coordinates[0], coordinates[1]])
            
            # position barrel geometries
            for c in range(self.nBarrels):
                barrel_geometry.append(Point(self.coordinates[0,c], self.coordinates[1,c]).buffer(stimSize))
                                   
            time_pattern = [1]

            # loop through barrels
            for b in range(self.nBarrels):  
                img = Image.new('L', (1024, 768), 0)
                self.draw_poly(barrel_geometry[b], img) 
                self.time_sequence(img, b+1, time_pattern, folder)
                

        # For spots feedback (For Dorian)      
        if stimPath.endswith("point"):
            print("point")
                        
            time_pattern = [1,1,1,1,1,1,1,0,0,0]
            #time_pattern = [1,0,0,0,0,0,0,0,0,0]
            point_geometry = []
            img = Image.new('L', (1024, 768), 0)
            for c in range(self.nBarrels):  
                point_geometry.append(Point(self.coordinates[0,c], self.coordinates[1,c]).buffer(stimSize))

            # loop through barrels
            for b in range(int(self.nBarrels/2)):
                print(b)
                self.draw_poly(point_geometry[b], img)
            
            folder = stimPath + "/"                      
            for i in range(0,6):
                if (i > 0):   
                    time_pattern = [0,0,0,0,0,0,0,0,0,0]
                if (i == 2):   
                    time_pattern = [1,1,1,1,1,1,1,0,0,0]#uncomment here to generate non black frames for sham trial
                    #time_pattern = [0,0,0,0,0,0,0,0,0,0]#comment this during sham trials
                    img = Image.new('L', (1024, 768), 0)
                    # loop through barrels
                    for b in range(int(self.nBarrels/2),self.nBarrels):
                        print(b)
                        self.draw_poly(point_geometry[b], img)
                self.time_sequence(img, i, time_pattern, folder)  

        # For whole barrel map feedback              
        if stimPath.endswith("barrel_spots"):
            print("barrel_spots")
            # whole barrel map as 22 spots
            time_pattern = [1]
            point_geometry = []
            img = Image.new('L', (1024, 768), 0)
            self.nBarrels = 22
            for c in range(self.nBarrels):  
                point_geometry.append(Point(self.coordinates[0,c], self.coordinates[1,c]).buffer(stimSize))

            # loop through barrels
            for b in range(int(self.nBarrels)):
                print(b)
                self.draw_poly(point_geometry[b], img)
            
            folder = stimPath + "/"                      
            self.time_sequence(img, 1, time_pattern, folder)   
        
        # For test frames black and white            
        if stimPath.endswith("test"):
            print("test")
            for c in range(0, 2): # black and white frames
                folder = stimPath + "/"
                img = Image.new('L', (1024, 768), color = c*255) # color 0 is black, color 1 is white
                time_pattern = [1] # only one frame per sequence
                self.time_sequence(img, c, time_pattern, folder)
                
        # Reinitialize coordinates
        self.coordinates = []
                
    def startLiveCamera(self):  
        print("Start Live Camera")   
        self.cam = py.InstantCamera(py.TlFactory_GetInstance().CreateFirstDevice())
        print("working")
        self.cam.Open()
        print("working2")
        counter = 0
        grab = self.cam.StartGrabbing(200)
        print('Grab %i %s' % (counter, 'succeeded' if grab.GrabSucceeded() else 'failed'))
        while(self.cam.IsGrabbing()):
            print("working3")
            grab = self.cam.RetrieveResult(3000)
            self.figure3.suptitle('Live Image',color='b')
            self.ax3.axis('off')
            if (grab.GrabSucceeded()):
                data  = np.array(grab.GetBuffer()).astype(np.uint8)
                image = data.reshape(grab.GetHeight(), grab.GetWidth())
                    
        # Plot the camera live image
        self.ax3.imshow(image, interpolation = 'none', cmap = 'gray')  
        # refresh canvas
        self.canvas3.draw()

    def stopLiveCamera(self): 
        print("Stop Live Camera")   
        self.cam.StopGrabbing(1)
        self.cam.Close()

class Pyqtgraph_Window(pg.MultiPlotWidget, object):
    
    def __init__(self, parent=None):
        super(Pyqtgraph_Window, self).__init__(parent)
        
        # initialize the view box        
        self.vb = self.addViewBox(row=1, col=1)
        self.vb.setBackgroundColor('k')
        self.vb.setRange(rect=None, xRange=(-600,600), yRange=(-600,600), padding=None, update=True, disableAutoRange=True)
        
        # Get location of the source file and read the template map   
        self.source_path = os.path.dirname(os.path.realpath(__file__))        
        self.template = Image.open(self.source_path + "/template_map.tiff")  
        self.template = np.asarray(self.template)
        self.template = np.rot90(np.rot90(np.rot90(self.template)))
        self.template = pg.ImageItem(self.template)
        
        # Add the template image in the ImageView widget
        self.vb.addItem(self.template)
        
        self.template.setZValue(10)  # make sure this image is on top
        self.template.setOpacity(0.9)
        
        r4 = pg.ROI([0,0], [494,494], removable=True)
        r4.addRotateHandle([1,0], [0.5, 0.5])
        r4.addRotateHandle([0,1], [0.5, 0.5])
        
        self.vb.addItem(r4)
        
        self.template.setParentItem(r4)
                
        proxy = QtGui.QGraphicsProxyWidget()
        self.button = QtGui.QPushButton('Load Barrels')
        self.button.clicked.connect(self.loadMap)
        proxy.setWidget(self.button)
        
        proxy2 = QtGui.QGraphicsProxyWidget()
        self.button2 = QtGui.QPushButton('Save Aligned Images')
        self.button2.clicked.connect(self.saveImages)
        proxy2.setWidget(self.button2)
                
        p1 = self.addLayout(row=2, col=0)
        p1.addItem(proxy,row=1,col=1)
        
        p2 = self.addLayout(row=2, col=1)
        p2.addItem(proxy2, row=1, col=1)
        
    def loadMap(self):
            
        iname = QtGui.QFileDialog.getOpenFileName(self, 'Open file', 
                      'f:\\',"Image files (*.tiff *.tif *.png *.jpeg *.jpg)")    
         
        barrel_map_path = iname 

        # Read the barrel map and resize it to the size of the stimulus image
        img = Image.open(barrel_map_path).convert('L')
        img = img.resize((659, 494))
        img = np.rot90(np.rot90(np.rot90(img)))
        
        
        r5 = pg.ROI([0,0], [659,494], removable=True)
        r5.addRotateHandle([1,0], [0.5, 0.5])
        r5.addRotateHandle([0,1], [0.5, 0.5])
        
        img2 = pg.ImageItem(img)
        
        img2.setZValue(5)  # make sure this image is on top
        img2.setOpacity(0.5)
        
        self.vb.addItem(img2)
        
        self.vb.addItem(r5)
        
        img2.setParentItem(r5)
                
        self.vb.setAspectLocked(True)
        
    def saveImages(self):
        print("save images")
        # create an exporter instance, as an argument give it
        # the item you wish to export
        exporter = pg.exporters.ImageExporter(self.vb)

        # set export parameters if needed
        exporter.parameters()['width'] = 100   # (note this also affects height parameter)

        # save to file
        exporter.export('fileName.png')

               
if __name__ == '__main__':
    
    app = 0    
    app = QtGui.QApplication(sys.argv)
    if not app: # create QApplication if it doesnt exist 
        app = QtGui.QApplication(sys.argv)
        app.aboutToQuit.connect(app.deleteLater)    
    
#    viewer = Pyqtgraph_Window()
#    viewer.setWindowTitle('Template Alignment GUI')    
#    viewer.show()
    
    main = Window()
    main.setWindowTitle('GENERATOR')
    ##main.setFixedSize(1500, 900)
    main.show()
        
    app.exec_()